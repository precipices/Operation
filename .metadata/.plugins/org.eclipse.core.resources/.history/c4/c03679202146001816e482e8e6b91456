package com.operation.server;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

import com.operation.common.Message;
/**
 * 本类为线程池,用来存放所有的线程
 * @author pre
 *
 */
public class ThreadPool {
	//存放待连接线程
	private static ArrayList<ServerThread> waitThreads = new ArrayList<ServerThread>();
	//存放已连接到客户端的线程,String为用户id
	private static Map<String,ServerThread> serverThreads = new HashMap<String,ServerThread>();
	//
//	private static Map<String,Message> messages = new HashMap<String, Message>();
	private static ArrayList<Message> messages = new ArrayList<Message>();
	
	public static boolean addMessage(Message message) {
		messages.add(message);
		return true;
	}
	public static Vector<Message> getMessages(String id){
		Vector<Message> ms=new Vector<Message>();
		for(Message m:messages) {
			if(m.getToId().equals(id)) {
				ms.add(m);
			}
		}
		return ms;
	}
	public static boolean removeMessage(Message message) {
		synchronized (messages) {
			for(Message m:messages) {
				if(m.equals(message)) {
					messages.remove(m);
				}
			}
		}
		return true;
	}

	public static void addWaitThread(ServerThread waitThread) {
		waitThreads.add(waitThread);
	}
	public static void removeWaitThread(ServerThread waitThread) {
		waitThreads.remove(waitThread);
	}
	public static void addServerThread(String id,ServerThread serverThread) {
		if(serverThreads.get(id)!=null) {
			System.out.println("id已登陆，为方便测试，暂时不限制");
			
		}
		serverThreads.put(id,serverThread);
	}
	public static void removeServerThread(String id) {
		serverThreads.remove(id);
	}
	public static int getWaitThreadsSize() {
		return waitThreads.size();
	}

	//存放各个Message


}
